1. open Terminal
2. type python3
3. >>> and what you want
4. >>> a=6
5. >>> b=2
6. >>> a/b
7. quit() or ctrl + z

python3 hello.py

В зависимости от версии Python и платформы, если вы не установили пере­
менную среды PATH своей системы так, чтобы она включала каталог, где установлен Python, то к слову python может потребоваться добавить полный путь к исполняемо­му файлу Python. В Unix, Linux и похожей среде таким каталогом часто оказывается
/usr/local/bin/python или /usr/bin/python3


 python script.py > save.txt
В итоге три строки вывода, показанные в предыдущем запуске, вместо отображе­
ния сохраняются в файле save.txt. Прием общеизвестен как перенаправление
потока и работает для ввода и вывода в системах Windows и Unix.

Он удобен при
тестировании, т.к. вы можете писать программы, которые отслеживают изменения в
выводе других программ.


****************************************
Такие файлы обычно называются исполняемыми сценариями.
• Первая строка является специальной. Как правило, первая строка сценариев на­
чинается с символов # !, за которыми следует путь к интерпретатору Python на
компьютере.

• Сценарии обычно имеют права на выполнение. Как правило, файлы сценариев
помечаются как исполняемые файлы для указания операционной системе, что
они могут запускаться в качестве программ верхнего уровня. В системах Unix та­кой трюк достигается с помощью команды, подобной chmod +х имя-файла.ру.
***************************
Питоновский скрипт:
файл my или my.py (без разницы, если не импортируем этот файл)

#!/usr/bin/python3
x = 3
print(x)

Пишем в терминале:
chmod +x my

Запускаем:
./my

Вывод:
3
**************************
Но такой комментарий,
как в первой строке файла brian, предназначен специальной для Unix, потому что
командная оболочка использует его для выполнения программного кода в оставшейся
части файла.


**************
комментария следующего вида:
#!/usr/bin/env python
print("Thanks")
В данном случае программа env определяет местоположение интерпретатора
Python согласно настройкам пути поиска в системе (в большинстве командных оболо­
чек Unix за счет просмотра всех каталогов, перечисленных в переменной среды PATH).



***************
перенаправление входного потока на уровне командной оболоч­
ки системы (например, 
python spam.py < input.txt
такая комнда) точно так же, как опера­тор print позволяет делать это для вывода.

**************
Файл myy.py:

#!/usr/bin/python3
x = 3
print(x)

y=input()
print(y*3)

Файл input.txt:

Bla-bla-bla!

Файл vivod.txt:
(пустой)

КОманда в Терминале
./myy.py < input.txt > vivod.txt

Выдаст:
3
Bla-bla-bla!Bla-bla-bla!Bla-bla-bla!

******************************************


операции импорта в качестве финального шага
выполняют код в загружаемом файле. Из-за этого импортирование файла является еще
одним способом его запуска.
Например, если вы начнете интерактивный сеанс (из командной строки системы
или как-то иначе), тогда сможете запустить созданный ранее файл scriptl .ру с по­
мощью простого импорта (сначала удалите строку с вызовом input, добавленную в
предыдущем разделе, а то придется без веской причины нажимать <Enter>):
С:\code> С:\python33\python
»> import scriptl
Win32
1267650600228229401496703205376
Spam!Spam!Spam!Spam!Spam!Spam!Spam!Spam!
**********************************

Если на самом деле необходимо заставить Python выполнить файл снова в том же
самом сеансе, не останавливая его и не перезапуская, то взамен понадобится вызвать
функцию reload, доступную в стандартном библиотечном модуле imp (она является
просто встроенной функцией в Python 2.Х, но не в Python З.Х):
»> from imp import reload
»> reload(scriptl)
# Должна загружаться из модуля в Python З.Х (только)
Win32
65536
Spam!Spam!Spam!Spam!Spam!Spam!Spam!Spam!

*************
Импортирование и перезагрузка предоставляют естественный вариант запуска про­
грамм, потому что операторы импорта выполняют файлы в качестве своего последне­
го шага. Но как вы узнаете в части V, в более широкой схеме модули исполняют роль
библиотек инструментов. Однако базовая идея прямолинейна: по большей части модуль
представляет собой лишь пакет имен переменных, известный под названием пространс­
тво имен, и имена внутри такого пакета называются атрибутами. Атрибут — это простo имя переменной, которое прикрепляется к специфическому объекту (вроде модуля).
**************
******************
******************
Получить доступ к атрибуту title модуля в других компонентах можно двумя спо­
собами. Вы можете загрузить модуль целиком посредством оператора import и затем
уточнить имя модуля именем атрибута, чтобы извлечь его (обратите внимание, что
здесь вы разрешаете интерпретатору выводить автоматически):
% python
»> import myfile
>» myfile. title
'The Meaning of Life'
# Запустить Python
# Выполнить файл; загрузить модуль целиком
# Использовать имя атрибуте: . служит для уточнения
'The Meaning of Life'
В общем случае синтаксис выражения с точкой объект.атрибут позволяет из­
влечь любой атрибут, прикрепленный к любому объекту, и является одной из самых
распространенных операций в коде Python. Мы применяем ее для доступа к строко­
вой переменной title внутри модуля myfile — другими словами, my file, title.
В качестве альтернативы извлекать (в действительности копировать) имена из мо­
дуля можно с помощью операторов from:
% python
»> from myfile import title
»> title
'The Meaning of Life'
# Запустить Python
# Выполнить файл; копировать его имена
# Использовать имя напрямую: уточнять не нужно
'The Meaning of Life'
**************************

В этом простом примере существует толь­
ко одно такое имя — переменная title, которой присвоена строка. Но концепция
будет более полезной, когда вы начнете определять в своих модулях объекты вроде
функций и классов: объекты подобного рода становятся многократно используемыми
программными компонентами, к которым можно обращаться по именам из одного или
большего числа клиентских модулей.
********************************
Как только вы начинаете писать код модулей с множеством имен, становится по­
лезной встроенная функция dir — вы можете использовать ее для извлечения списка
всех имен, доступных внутри модуля. Приведенный ниже вызов возвращает список
строк Python в квадратных скобках (изучение списков начнется в следующей главе):
»> dir (threenames)
[’__ builtins__ ', '__ doc__ ’_____ file__ ', '__ name__ ', '__ package__', ’a’, ’b’, 'c']
Содержимое списка было отредактировано, т.к. оно варьируется в зависимости от
версии Python. Здесь важно отметить, что когда функция dir вызывается с именем
импортированного модуля в круглых скобках, она возвращает все атрибуты внутри
модуля. Ряд возвращаемых имен вы получаете “бесплатно ”: имена с ведущими и за­
вершающими двойными подчеркиваниями (__ X__) являются встроенными именами,
которые всегда предварительно определены Python и имеют специальный смысл для
интерпретатора, но в настоящий момент они не важны. Переменные нашего кода,
определенные присваиваниями (а, b и с), в результате вызова функции dir отобра­
жаются последними.
*******************************
спользование ехес для выполнения файлов модулей
Строго говоря, для выполнения кода, хранящегося в файлах модулей, существует
больше способов, чем было представлено до сих пор. Например, вызов встроенной
функции exec (open (’module .ру1) . read () ) является еще одним приемом запуска
файлов из интерактивной подсказки без импортирования и последующей перезаг­
рузки. Каждый такой вызов ехес выполняет текущую версию кода, прочитанную из
файла, не требуя перезагрузки в более позднее время (script 1 .ру находится в том
состоянии, в каком мы его оставили после перезагрузки в предыдущем разделе):
% python

»> ехес (open (’ scriptl.ру') . read ())
Win32
65536
Spam!Spam!Spam!Spam!Spam!Spam!Spam!Spam!
. . .Изменение scriptl .py в окне текстового редактора для вывода 2 ** 32.. .
»> ехес (open (’ scriptl. ру ’) . read ())
Win32
4294967296
Spam’Spam!Spam!Spam!Spam’Spam’Spam!Spam!
********************************************
Формально IDLE представляет собой программу Python, которая при создании
своих окон применяет инструментальный набор для построения графических поль­
зовательских интерфейсов tkinter (Tkinter в Python 2.Х) из стандартной библиотеки.
Такое решение делает среду IDLE переносимой (она работает одинаково на всех круп­
ных настольных платформах), но оно также означает необходимость наличия подде­
ржки tkinter для Python,
*********************
Применяйте аргумент -i команды python. Даже не добавляя операторы print
и не запуская под управлением pdb, при возникновении ошибок вы все равно
можете выяснить, что пошло не так. Если вы запустите свой сценарий в коман­
дной строке, указав аргумент -i 
(
например, python -i m.py
),
то Python войдет
в режим интерактивного интерпретатора (с подсказкой »>), когда сценарий за­
кончит работу, либо успешно дойдя до конца, либо из-за возникновения ошибки.
В этот момент вы можете вывести финальные значения переменных, чтобы полу­
чить больше деталей о том, что случилось в коде, т.к. они находятся в пространс­
Глава 3. Как пользователь выполняет программы
119тве имен верхнего уровня. В

*******************************
Вкратце
СПИСКИ предоставляют упорядоченные коллекции других объектов. 
СЛОВАРИ хранят объекты по ключам;

И списки, и словари могут быть вложенными, расти и уменьшать­
ся по требованию и содержать объекты любого типа.
********************************
Несмотря на ее заголовок, табл. 4.1 в действительности нельзя считать полной,
т.к. все, что мы обрабатываем в программах Python, является какой-то разновидностью
объекта. Скажем, когда мы выполняем сопоставление текста с образцом в Python, то
создаем объекты образцов, а когда пишем сценарий для работы с сетью, то приме­
няем объекты сокетов. Эти другие виды объектов, как правило, создаются путем им­
портирования и использования функций в библиотечных модулях (ге и socket для
сопоставления с образцом и для сокетов) и обладают своим поведением.
******************************
Не менее важно и то, что после того, как объект создан, он навсегда привязыва­
ется к своему набору операций; на строке можно выполнять только строковые опе­
рации, а на списке — только списковые операции. Формально это означает, что язык
Python динамически типизирован — модель, которая отслеживает типы автоматически,
не требуя объявления, но он также строго типизирован — ограничение, обусловливаю­
щее возможность выполнения на объекте только допустимых для его типа операций.
*********************************
Помимо выражений в состав Python входит несколько полезных числовых модулей
(модули — это просто пакеты дополнительных инструментов, которые мы импортиру­
ем для их применения):
>>> import math
»> math.pi
3.141592653589793
»> math. sqrt(85)
9.219544457292887
********************
»> import random
»> random. random ()
0.7082048489415967
>» random, choice ([1, 2, 3, 4])
1
***************************
Важно отметить, что знак “плюс” (+) для разных объектов означает отличающиеся
действия: сложение для чисел и конкатенацию для строк. 
Это общее свойство Python
позже в книге мы назовем полиморфизмом, — коротко говоря, смысл операции зависит
от объектов, к которым она применяется.
**********************************
Например, вы не сумеете изменить строку, присваивая значение символу в од­
ной из ее позиций, но всегда сможете построить новую строку и назначить ей то же
самое имя.
>» S
'Spam'
»> S[0] = ’z’
# Неизменяемые объекты модифицировать нельзя
...текст сообщения об ошибке не показан...
TypeError: ’str’ object does not support item assignment
Ошибка типа: объект str не поддерживает присваивание в отношении элементов
»> S = ’ z' + S [ 1: ]
# Но мы можем выполнять выражения для создания новых объектов
>» S
'zpam’
********************
Что касается основных типов, то числа, строки и кортежи неизменяемы,
а списки, словари и множества — нет; они могут свободно модифицироваться на месте,
как большинство новых объектов, которые вы будете создавать с помощью классов.
***************
***************
В качестве эмпирического правила запомните, что инс­трументальный набор Python делится на уровни: универсальные операции, охватываю­
щие множество типов, выглядят как встроенные функции или выражения (например,
len (X), X [0]), но операции, специфичные для типа, представляют собой вызовы ме­тодов (скажем, aString. upper ()). По мере все большего освоения Python поиск необ­
ходимых инструментов в этих категориях станет более естественным, а в следующем
разделе даются советы, которыми вы можете воспользоваться прямо сейчас.

*****************
для строки все методы
>>> dir(s)
['__add__', '__class__', '__contains__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getnewargs__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mod__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__rmod__', '__rmul__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'capitalize', 'casefold', 'center', 'count', 'encode', 'endswith', 'expandtabs', 'find', 'format', 'format_map', 'index', 'isalnum', 'isalpha', 'isascii', 'isdecimal', 'isdigit', 'isidentifier', 'islower', 'isnumeric', 'isprintable', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'maketrans', 'partition', 'removeprefix', 'removesuffix', 'replace', 'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill']
*****************************
Функция dir просто выдает имена методов. Чтобы выяснить, что делает тот или
иной метод, его имя можно передать функции help:
»> help (S. replace)
Help on built-in function replace:
Справка по встроенной функции replace:
*****************************************
msg = """I am 
many lines. 

You see."""

print (msg)

output:
I am 
many lines. 

You see.
******************
>>> import re
>>> match = re.match('(.*)[*%](.*)[*%](.*)[*%](.*)[*%](.*)','hello*hi*I%am%good')
>>> match.groups()
('hello', 'hi', 'I', 'am', 'good')
>>> 
**************************
Списки
»> L.append('N1’)
»> L
[123,
’spam’, 1.23,'N1’]
# Увеличение: добавление объекта в конец списка
»> L.pop(2)
# Уменьшение: удаление элемента из середины
1.23
>» L
[123,'spam', 'N1']
# del L[2] также выполняет удаление из списка

Списковый метод append увеличивает размер списка и помещает объект в конец;
метод pop (или эквивалентный оператор del) удаляет элемент по заданному смеще­нию, приводя к уменьшению списка.
*****************
»> М = 
[ 
[1, 2, 3] ,
[4, 5, 6],
[7, 8, 9]
]
>» М
# Матрица 3 х 3 в виде вложенных списков
# При использовании квадратных скобок код
# может занимать несколько строк

>>> М[1]
# Получить строку 
[4, 5, б]


»> соl2 = [row[1] for row in M]
>» col2
[2, 5, 8]

********************
»> list (range (-6, 7, 2))
[-6, -4, -2, 0, 2, 4, 6]
************************
venv предназначен для создания виртуального окружения (далее просто "окружение") для вашего проекта.
$ sudo apt instsll python3-venv # установить venv
$ python3 -m venv venv
$ source venv/bin/activate
$ which python
$ deactivate
$ pip
$ pip -V
$ pip list # покажет все установленные библиотеки
$ pip install six
$ pip freeze > reqiurements.txt
можно прописать reqiurements.txt и запустить команду
$ pip install -Ur reqiurements.txt
*****************************

Python
Перевод чисел из десятичной системы счисления
print(bin(123)) # '0b1111011'
print(oct(123)) # '0o173'
print(hex(123)) # '0x7b'

Python
Перевод в десятичную систему
int(0b10000010000101) # 8325
int(0o20205) # 8325
int(0x2085) # 8325

Python
Перевод строки в число
int("8325")
8325

*******************************

# -*- coding: utf-8 -*-
# extract_ZIP.py
import zipfile, sys
#открываем zip-файл
zip = zipfile.open(sys.argv[1], "r:zip")
zip.extractall()
# python example2.py jimstar.zip
*********************
# -*- coding: utf-8 -*-
# extract_TAR.py
import tarfile, sys
#открываем tar-файл
tar = tarfile.open(sys.argv[1], "r:gz")
tar.extractall()
# python example2.py jimstar.tar
******************
#add_file_to_tar
import tarfile, sys
tar=tarfile.open("archive.tar.gz", "w:gz")
tar.add(sys.argv[1])
# python3 add_file_to_tar.py file.txt
*******************
#CRACK
import zipfile 
 
def crack_password(password_list, obj):
    # tracking line no. at which password is found
    idx = 0
 
    # open file in read byte mode only as "rockyou.txt"
    # file contains some special characters and hence
    # UnicodeDecodeError will be generated
    with open(password_list, 'rb') as file:
        for line in file:
            for word in line.split():
                try:
                    idx += 1
                    obj.extractall(pwd=word)
                    print("Password found at line", idx)
                    print("Password is", word.decode())
                    return True
                except:
                    continue
    return False
 
 
password_list = "rockyou.txt"
 
zip_file = "archive.zip"
 
# ZipFile object initialised
obj = zipfile.ZipFile(zip_file)
 
# count of number of words present in file
cnt = len(list(open(password_list, "rb")))
 
print("There are total", cnt,
      "number of passwords to test")
 
if crack_password(password_list, obj) == False:
    print("Password not found in this file")
*****************************
#!/usr/bin/python3
x = 3
print(x)

y=input()
print(y*3)
***********************************
# подключение к постгрес
import psycopg2

conn = psycopg2.connect(
host='localhost',
port='5432',
database='appdb',
user='app',
password='p@ssw0rd')

cur = conn.cursor()
cur.execute('SELECT * FROM book')
rows = cur.fetchall()
for row in rows:
	for elem in row:
		print ("{:<25}".format(elem), end=' ')
	print ()
conn.close()
*****************************
# box_massage
import tkinter as tk

window = tk.Tk()
window.title("Hello world")
window.geometry("300x300")

hello = tk.Label(text="Hello world!")
hello.pack()
button = tk.Button(text="Click me!")
button.pack()

tk.mainloop()
*********************************
Например, помещая
списковое включение в круглые скобки, можно создавать генераторы, которые произво­дят результаты по требованию. В целях иллюстрации встроенная функция sum сум­мирует элементы в последовательности; вот пример суммирования всех элементов встроках нашей матрицы по требованию:
>» G - (sum(row) for row in M) # Создать генератор сумм элементов в строках
»> next(G)
6
»> next(G) # Запустить протокол итерации next ()
15
»> next(G)
24
Встроенная функция map способна выполнять похожую работу, генерируя результа­ты прогона элементов через функцию, по одному за раз и по запросу.
*************************
»> {i : sum(M[i]) for i in range (3)}
# Создать таблицу ключей/
# значений сумм элементов в строках
{0: 6, 1: 15, 2: 24}
*****************************
»> [ord(x) for х in ’spaam']
# Список порядковых чисел для символов
[115, 112, 97, 97, 109]

»> {ord(x) for х in ’spaam’}
# Множество с удаленными дубликатами
{112, 97, 115, 109}


145»> {x: ord(x) for x in 'spaam'}
# Словарь с уникальными ключами
{'p':112, 'a':97, 's':115, ’m’: 109}
**********************************
DICT
>>> D = {’food’: ’Spam', ’quantity’: 4, ’color’: 'pink'}
Мы можем индексировать этот словарь по ключу, чтобы извлекать и изменять зна­
чения, связанные с ключами. Операция индексации словаря имеет такой же синтак­
сис, как для последовательностей, но элементом в квадратных скобках будет ключ, а
не относительная позиция:
»> D['food']
# Извлечь значение, связанное с ключом 'food'
'Spam'
»> D['quantity'] += 1
# Добавить 1 к значению, связанному с ключом 'quantity'
»> D
{'color':’pink’, 'food': 'Spam', 'quantity': 5}
*********************
>>> D = {}
>>> Df'name'] = 'Bob'
>>> D[’job'J = 'dev'
>>> D [' age' ] = 40
# Присваивание приводит к созданию ключей
>>> D
{’age: 40, ’job’: ’dev', ’name’: ’Bob’}
*******************************
 py -3.9 -c "import time; print(time.asctime())"
**************************************
*************************************
************************************
 
 FILES
 
>>> f = open(* data. txt ’ , ’w') # Создать новый файл в режиме записи ('w')
>>> f.write('Hello\n') # Записать в него строки символов
>>> f. write (’world\n') # Возвратить количество записанных элементов # в версии Python З.Х
б
>>> f.close() # Закрыть для сбрасывания буферов вывода на диск

Код создает файл в текущем каталоге и записывает в него текст (имя файла мо­
жет содержать полный путь к каталогу, если нужно получить доступ к файлу где-то в
другом месте на компьютере). Чтобы прочитать то, что было записано, необходимо
повторно открыть файл в режиме обработки ’ г ’ для чтения текстового ввода (он вы­
бирается по умолчанию, если в вызове строка режима не указана). Затем следует про­
читать содержимое файла в строку и отобразить ее. В сценарии содержимое файла
всегда будет строкой независимо от типа находящихся в нем данных:

>>> f = open (’data.txt’) # 'г' (чтение) - стандартный режим обработки
>>> text = f.read() # Прочитать все содержимое файла в строку
>>> text 
'Hello\nworld\n'
>>> print (text) # print интерпретирует управляющие символы
Hello
world
>>> text.split() # Содержимое файла - всегда строка
['Hello’, 'world']

**************************************
*************************************
************************************
SCRIPTS

#!/usr/bin/env python3
print("Hello, I am script")

Переименовываем
$ cp helloworld.py helloworld

Делаем исполняемым
$ chmod +x helloworld

Добавляем путь
$ PATH=$PATH:/home/alex/alex_scripts

Из любой папки пишем нашу команду
$ helloworld

Hello, I am script

**************************************
*************************************
************************************
# В данной строке импортируется something_we_want
import something_we_want 

# В данной строке импортируется something_we_want, как aww(логично и просто)
import something_we_want as aww 

# В данной строке импортируется из something_we_want something(логично и просто)
from something_we_want import something

# В данной строке импортируется из something_we_want something, как s(логично и просто)
from something_we_want import something as s

# Синтаксис as позволяет обращаться к импортируемому по новому нами описанному 
# далее имени(это работает только в рамках нашего файла)
******************************************
****************************************
